# 作者:李一安
# 2025年01月03日21时12分51秒
# 1713450722@qq.com

# 可变类型和不可变类型

# 可变类型：list、dict、set、bytearray、array.array、memoryview
# 不可变类型：int、float、complex、bool、str、tuple

# 对于可变类型，如果对其中一个元素进行修改，则其他元素也会发生变化。
# 对于不可变类型，如果对其中一个元素进行修改，则其他元素不会发生变化。


def test1(a):

    # 此时函数内的a是形参，是完全独立的另一个变量，在栈内存中有自己独立的内存地址
    # 但是由于实际值与实参相同，且实际数据存放于堆内存中且唯一，故而虽然两个变量在栈内存中分别独立，但在栈内存中存放的是同一个地址
    # 也就是说指向同一个堆内存地址
    # 而后续的修改只是修改了形参，而非实参

    print(f"a = {a}, id(a) = {id(a)}")
    a = 20
    print(f"a = {a}, id(a) = {id(a)}")


a = 10

print(f"a的值：{a}，函数调用前a在堆内存中的地址：{id(a)}")

test1(a)

print(f"a的值：{a}，函数调用后a在堆内存中的地址：{id(a)}")


# 基础数据类型都是不可变类型，所以在函数中修改基础数据类型的值，并不会影响到原来的值。
# 而对于可变类型，在函数中修改可变类型的值，会影响到原来的值。
# 有点像C++中函数传参时func(&a)，这样形参修改时会连同实参一起修改（实参会效仿形参的行为）。


# 例如：

def test2(new_list):

    # new_list=[10,20,30] # [10,20,30]是堆内存中的另一个数据，拥有独立的地址，这是改变形参变量指向的堆内存地址，并不会影响到实参

    new_list[0] = 10 # 这里的实质是基于实际数据在堆内存中的地址来进行修改，所以会影响到实参，就像C语言中传入函数的数组名一样。


list1 = [1, 2, 3]
list3 = [1, 2, 3]

print(f"list1在堆内存中的地址：{id(list1)}，list3在堆内存中的地址：{id(list3)}")
# 对于可变数据类型在堆内存中并不是唯一的，所以地址不同。


# 并且可变数据类型可以在不变化自己的堆内存首地址的情况下进行增删改操作。

print(f"执行函数以前list1的值：{list1}，list1在堆内存中的地址：{id(list1)}")

test2(list1)

print(f"执行函数以后list1的值：{list1}，list1在堆内存中的地址：{id(list1)}")


