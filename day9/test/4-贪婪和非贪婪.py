# 作者:李一安
# 2025年02月26日18时15分57秒

# 正则表达式的贪婪和非贪婪

# 正则表达式默认为贪婪模式
# 即当正则表达式中有以下量词时，会尽最大限度地匹配字符

# *     匹配前一个字符出现 0 次或者更多次，即可有可无。
# +     匹配前一个字符出现 1 次或者更多次，即至少有 1 次。
# ?     匹配前一个字符出现 1 次或者 0 次，即只会有 1 次或 0 次。若匹配到0次，则正则表达式中的扫描指针继续往后走，字符串中的扫描指针留在原位；且正则引擎一般都会统筹后面的字符串，[字符集]?是可选的，[字符集]是必须满足的，在字符串不够匹配的情况下，不论这两者的先后顺序，都会优先满足[字符集]
# {m}   匹配前一个字符出现 m 次，限定出现次数。若不够则返回 None，若更多则仅到 m 次，匹配过程中出现不在字符集中的字符返回 None
# {m,n} 匹配前一个字符出现从 m 到 n 次，限定出现次数。不够范围、超出范围、或在还没扫描至范围下限时就遇到不存在于字符集中的字符时，结果同上；但若在[m,n]范围内匹配过程中扫描到不在字符集中的字符，则停止并返回已经匹配的字符，否则就一直匹配至上限n次



import re



def use_greedy():

    s = "This is a number 234-235-22-423"

    # 但其实贪婪也是有限度的，当正则表达式有以下量词时，正则系统会统筹整个字符串，限定贪婪的最大值，使得正则表达式中所有的匹配字符都能被匹配到。
    ret = re.match(r".+(\d+-\d+-\d+-\d+)", s)
    print(ret.group(1))

    # 用 ? 去修饰以上的量词，就会使得正则表达式进入非贪婪模式，即量词的效能会降低，只会匹配到尽可能少的字符，直到?后的正则表达式能够匹配到字符为止，若?后面没有正则表达式，则量词效能会降至最低。
    ret = re.match(r".+?(\d+-\d+-\d+-\d+)", s)
    print(ret.group(1))



    print(re.match(r"aa(\d+)", "aa2343ddd").group(1)) # 2343

    print(re.match(r"aa(\d+?)", "aa2343ddd").group(1)) # 2

    print(re.match(r"aa(\d+)ddd", "aa2343ddd").group(1)) # 2343

    print(re.match(r"aa(\d+?)ddd", "aa2343ddd").group(1)) # 2343


def use_r():
    """
    r的作用, 原生字串
    所以所有的正则表达式都要加r前缀，表示原生字串
    因为字符串中的双斜杠\\会被转义为\，所以要用原始字符串来表示原生字符串
    加r前缀后，正则表达式中不需要再用\\来表达\，直接写\即可
    但是字符串里的依然是原生字符串
    :return:
    """
    mm = "c:\\a\\b\\c"
    print(mm)
    print(re.match(r"c:\\", mm).group())



# flags参数
# re.A  让\w \W 仅匹配ASCII字符
# re.I  让匹配时不再区分字母大小写
# re.S  让. 匹配包括换行在内的所有字符，包括\n

def use_option():
    print(re.match(r'\w*','abc函',flags=re.A).group())
    print(re.match(r'a*', 'aA',flags=re.I).group())
    print(re.match(r'.*','abc\ndef',flags=re.S).group())

if __name__ == '__main__':
    # use_greedy()
    # use_r()
     use_option()